# Go for python developers
An introduction to golang for pythonistas

Olivier Roux
Go and Python developer
olivier.roux@deepki.com

## About me

Learned Python in 1999 and Go in 2016.

Used Python full-time for about 7 years.

Used Go full time for more than 4 years.

Python and Go are my two favorite languages. I always miss one when I use the other.


## Foreword

Throughout this talk, we'll be talking about Go 1.x and Python 3.x


## Why learn a language that your company is not using?

- It will introduce you to new ways of doing things

- It will give you the bigger picture of the programming languages ecosystem.

- It will make you more desirable on the market.

- A larger toolset makes you a better developer.


## Why Go?

The Hacker Earth 2020 survey showed that among students (29%) and experienced developers (32%),
Go has emerged as the clear winner for the most sought-after programming language.

.image img/sought-after.png


## Why is it so popular?

- Easy to learn and easy to master.

- Statically typed, but with a dynamic feel.
  
- Standing on the shoulders of giants

  The creators of Go (Robert Griesemer, Rob Pike, and Ken Thompson) are pioneers of modern Computer Science.

- Language-level concurrency features.

- Expansive "batteries included" standard library.

- Unlike Python, Go is compiled to machine code. This makes it *a lot* faster.
  
- The compilation is so fast that it feels like an interpreted language.

- Great tools.


## Where is Go being used?

- DevOps

  Kubernetes and Docker are written in Go.

- Distributed services

  Because of native concurrency, Go is well suited for creating APIs, web servers, and microservices.

- General Backend infrastructure

  Go speed, simplicity, and memory safety has made it a popular choice as a backend language.

  Many organizations are rewriting their existing infrastructure in Go.


## The most useful slide of this presentation

"go" as a search keyword is completely useless.

Use "golang" instead, you'll find what you're looking for.

You're welcome.


## Hello, world!

.play hello/main.go

As you can see, the syntax is very simple and clean.

Unlike Python, code *must* be in a `main` function if we want to produce an executable.

Go uses `camelCase` for everything.

Capitalized names are exported. The other names are private.


## Static typing

Python is dynamically typed. Any variable can change type at any point.

Go is statically typed. Once a type has been assigned to a variable, it can not be changed.

Most runtime errors in python would be detected as compilation errors in Go.


## Type declaration

.play variables/main.go


## Style

Like Python, Go tries to force developers to write beautiful code.

It goes even further.

- Unused variables will throw compilation errors

- Unused imports will throw compilation errors.

- Code that does not look like what gofmt produces will not compile.
  
  Most people have a love/hate relationship with gofmt.


## Data types

- Ten types of integers, but you mostly use `int`, which is the same as Python's.
  - `int8`, `int16`, `int32`, `int64`
  - `uint8`, `uint16`, `uint32`, `uint64`
  - `int` and `uint` are either 32 or 64 bits depending on the target architecture.

- Floats are either `float32` or `float64`. Python's floats are 64 bits.

- Strings are immutable and UTF-8 encoded, same as Python.

- Booleans are called `true` and `false`

- Go's `nil` is a value. Python's `None` has its own type.

- Go has constants. Python doesn't.


## Collections

- Slices can be used like Python's lists.

  Each element has to be of the same type.

- Maps can be used like Python's dictionaries.

  The type of the keys and the type of the values has to be the same for each entry.

- No sets, but maps with empty values can achieve the same effect.

- No tuples

- Nothing fancy like OrderedDict in the standard library


## Structs

A struct is a mutable collection of fields.

You can attach methods to them.

They are user-defined data types.

They are similar to Python's classes without the inheritance.

Go is not object-oriented.
Instead, Go uses composition to achieve a very similar effect.

Inheritance = "is a". Composition = "has a".

Methods are written like regular functions with a special "receiver" argument.
There is no "class" block.


## Structs

.play struct/main.go


## Pointers

They don't exist in Python.

Go pointers work just like C pointers, but safe (no arithmetics allowed).

In Python, arguments are passed by reference.

In Go, arguments are passed by value.

Pointers are a way for a function to modify the content of the arguments it received.


## Pointers

.play pointer/main.go


## Errors

Go does not have exceptions.

In Go, errors are explicitely returned by some functions.

Go errors are annoying at first, but once you get used to them
they are *a lot* easier to work with than exceptions.

Because errors are explicit, the way a function behaves is easier to predict
and you never feel the need to "except everything".

Being forced to deal with the errors instead of letting exceptions propagate
also means that your code won't crash unless you explicitely let it.


## Errors

.play error/main.go


## Interfaces

Python has duck-tying: if it looks like a duck and quacks like a duck, it's a duck.

In practice, it's difficult to agree on what a duck is.

Go has formally defined behaviors called interfaces. They are abstract types.

They are just a list of methods. They don't care about data.

Concrete types implement interfaces just by having the right methods.
No knowledge of the interface is necessary.

Interfaces will emerge from implementation patterns.

They're a great tool for mocking.


## Goroutines

Called coroutines in every other language, including Python's asyncio.

They feel like threads in the sense that they can share memory.

Unlike threads, they are very lightweight. Switching context is very cheap.

It is not uncommon for a single program to use thousands of them at the same time.

Unlike Python's asyncio, they can be used to optimize CPU bound algorithms as well.


## Goroutines

.play goroutine/main.go


## Channels

Functions called as goroutines can not return values, but they can share data.

Channels are queue-like objects that let us do just that without worrying about concurrent access.

Code execution stops on a channel read until someone writes into it.

Code execution stops on a channel write until someone is ready to read from it.

Channels are a way to synchronize goroutines.


## Channels

.play channel/main.go


## Generators ?

.play generator/main.go


## Context managers ?

.play defer/main.go

## The zen of Python

.code zen.txt

## Zen is good

This is a nice list.

I agree with most of it.

(Although it seems that Python doesn't, sometimes)


## Go is Zen

Go meets nearly all of Tim Peters' criteria (maybe not that one about being Dutch).

Often more than Python itself.

Let's take a look at some of them.


## Beautiful is better than ugly

Go has a lightweight, regular syntax reminiscent of C. It's very familiar for most people.

The way `gofmt` enforces style makes go code consistent across code bases.

More so than Python's indentation.

But beauty is in the eye of the beholder, so let's move on.


## Simple is better than complex

Go only has 25 reserved keywords, Python has 33.

They're both cheating with globals though. :)

But in general, Go just has less of everything.


## Simple is better than complex

Methods are just functions.

They can be declared on any type. No need for classes.

.code zen/method.go


## Simple is better than complex

No constructors or destructors

A constructor is just a funtion

.code zen/constructor.go


## Simple is better than complex

- No inheritance.
- No decorators.
- No named or optional arguments.
- No list comprehension.
- No generators.
- No exceptions.


## Explicit is better than implicit

- Explicit error handling.
- Explicit dependencies.
- No implicit numeric conversion.
- Structs properties order define memory layout (no hidden cost).
- Explicit definition of abstractions through interfaces.
- Explicit export of names through naming (capitalized means exported).


## Flat is better than nested

"Bail early", aka "align the happy path to the left" is idiomatic go code.

.code zen/happy.go


## Flat is better than nested

- Methods are not nested inside classes.

- Package name space is flat.

- Multiple files that comprise one package share one name space.


## Sparse is better than dense

Go syntax does not encourage crazy one-liners

- No list comprehension.
- No ternary operator.

When reading Go code the control flow is obvious.


## Readability counts

Go was designed at Google for teams of hundreds/thousands of programmers.

Readability is of paramount importance.

- The gofmt tool enforces "one true style" (No more stupid arguments).

- Type inference saves a lot of typing, but not at the cost of readability.
  
- Many other language design decisions were made in the name of readability


## There should be one obvious way to do it

I would argue that this is more true of Go than Python.


## Go has proverbs!

- Don't communicate by sharing memory, share memory by communicating.
- The bigger the interface, the weaker the abstraction.
- Gofmt's style is no one's favorite, yet gofmt is everyone's favorite.
- A little copying is better than a little dependency.
- Clear is better than clever.
- Design the architecture, name the components, document the details.

etc.


## Now is better than never

Learn Go today! It's easy.

- Productive in one day.
- Efficient in one week.
- Expert in one year.

Start with [A Tour of Go](https://tour.golang.org) (half a day)

Then read [Effective Go](https://golang.org/doc/effective_go) (half a day)

And check out [Go by example](https://gobyexample.com)
